setContentView的源码解读

## 一、实现换肤面对的问题：

1. 每次打开都是新的皮肤
2. 换肤之后所有的activity里面的View都要换肤
3. 每次从新进入app也需要换肤

## 二、实现换肤方案：

1. 每个activity里面都把需要换肤的View给找出来，然后调用代码去换肤（死板的方法）；
2. 获取activity里面的根布局，然后通过不断循环获取子View，通过Tag（View的Tag属性）；
3. 拦截View的创建（推荐）

如果要拦截View，就需要知道系统是怎样加载View的

## 三、Activity和AppCompatActivity的区别

### 区别：一个TextView，两种结果

我们先看一种现象，我们在布局文件中放置一个TextView，然后在我们的MainActivity中去打印

```java
override fun onCreate(savedInstanceState: Bundle?) {
	Log.d("MainActivity", tv_letter.toString())
}
//结果：
//MainActivity继承自Activity
android.widget.TextView{4b9ea62 G.ED..... ......ID 0,0-0,0 #7f0700f6 app:id/tv_letter}

//MainActivity继承自AppCompatActivity
androidx.appcompat.widget.AppCompatTextView{4b021e0 G.ED..... ......ID 0,0-0,0 #7f0700f6 app:id/tv_letter}
```

思考：布局里面明明是TextView，为什么继承自AppCompatActivity就变成了AppCompatTextView

为了搞清楚这个现象，我们先看一下各自的源码

首先我们看一下继承自Activity的源码，我们先从MainActivity中的setContent()方法追进去，

### 1. 继承自Activity

Activity.java

```java
public void setContentView(int layoutResID) {
    getWindow().setContentView(layoutResID);
    initWindowDecorActionBar();
}

public void setContentView(View view) {
    getWindow().setContentView(view);
    initWindowDecorActionBar();
}

public void setContentView(View view, ViewGroup.LayoutParams params) {
    getWindow().setContentView(view, params);
    initWindowDecorActionBar();
}
```

这里Activity中提供了三个重载方法，但是都调用了getWindow().setContentView(view, params);方法。这里补充一下Window的知识点

#### Window的知识点

![image-20201011140336753](F:\typora\图片\image-20201011140336753.png)

1. Window是一个抽象类，提供了绘制窗口的一组通用API。
2. PhoneWindow是Window的具体继承实现类。而且该类内部包含了一个DecorView对象，该DectorView对象是所有应用窗口(Activity界面)的根View。
3. DecorView是PhoneWindow的内部类，是FrameLayout的子类，是对FrameLayout进行功能的修饰（所以叫DecorXXX），是所有应用窗口的根View 。

依据面向对象从抽象到具体我们可以类比上面关系就像如下：

Window是一块电子屏，PhoneWindow是一块手机电子屏，DecorView就是电子屏要显示的内容，Activity就是手机电子屏安装位置。

由于Window是一个抽象类，我们只能从他的实现类中去找setContentView的源码

#### 1.1 PhoneWindow.java的setContentView

```java
@Override
public void setContentView(int layoutResID) {
    //...
    if (mContentParent == null) {
        installDecor();
    } else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) {
        mContentParent.removeAllViews();
    }
    //...
    //因为layoutResID是我们传过来的activity_main，所以这里是把返回回来的系统布局mContentParent和activity_main绑定起来了
    mLayoutInflater.inflate(layoutResID, mContentParent);
    final Callback cb = getCallback();
    if (cb != null && !isDestroyed()) {
        cb.onContentChanged();
    }
}
```

在setContentView中，先判断mContentParent是否为null，如果是第一次调用这个方法，就会进`installDecor()`方法里面，以后再进入的时候会根据是否设置FEATURE_CONTENT_TRANSITIONS Window属性（默认false）来决定是否移除mContentParent的所有子View。

下面的mLayoutInflater.inflate()将我们的传来来的布局id转换成View树，并添加至mContentParent中。（这里的mLayoutInflater是在PhoneWindow的构造函数中实例化的`mLayoutInflater = LayoutInflater.from(context);`）

上面是Activity三个重载方法的一种，其余两种也是类似，但是没有传`layoutResID`过去，所以他是将我们的传过去的View，直接追加到了mContentView上面

```java
@Override
public void setContentView(View view) {
    setContentView(view, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));
}

@Override
public void setContentView(View view, ViewGroup.LayoutParams params) {
    if (mContentParent == null) {
        installDecor();
    } else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) {
        mContentParent.removeAllViews();
    }
	mContentParent.addView(view, params);
}
```
除了记载View外，mContentParent.removeAllViews();也值得我们注意，因为他提供了程序调用多次setContentView的保证：重复调用时，先移除所有子View

#### 1.2 PhoneWondow中的installDecor方法

```java
private void installDecor() {
    mForceDecorInstall = false;
    if (mDecor == null) {
        mDecor = generateDecor(-1);
    }
    if (mContentParent == null) {
        mContentParent = generateLayout(mDecor);
	}
}

```

在installDecor方法中，他先判断了DecorView(该类是FrameLayout子类，即一个ViewGroup视图)是否存在，如果不存在，就去创建+初始化他，而generateDecor方法也很简单，直接就是new一个DecorView对象返回。

```java
protected DecorView generateDecor(int featureId) {
    return new DecorView(context, featureId, this, getAttributes());
}
```

从setContentView那里我们知道，installDecor方法就是在mContentParent==null的时候调用的，所以这个方法的主要作用还是创建mContentParent对象，我们进到generateLayout()方法里面

#### 1.3 generateLayout方法——创建mContentParent

```java
protected ViewGroup generateLayout(DecorView decor) {
    //获取我们设置的android:theme属性
    TypedArray a = getWindowStyle();
    //做一些简单的判断，看看是否是styleable中的一种,然后去请求
    //依据主题style设置一堆值进行设置
    if (a.getBoolean(R.styleable.Window_windowNoTitle, false)) {
        requestFeature(FEATURE_NO_TITLE);
    } else ...
	//重点：layoutResource
    // Inflate the window decor.填充window的decor
    int layoutResource;
	//获取我们平时通过requestWindowFeature()设置的属性
    int features = getLocalFeatures();
    //做各种判断，给layoutResource赋值（用系统的布局给它赋值）
    //根据设定好的features值选择不同的窗口修饰布局文件,得到layoutResource值
    if ((features & ((1 << FEATURE_LEFT_ICON) | (1 << FEATURE_RIGHT_ICON))) != 0) {
        if (mIsFloating) {
            layoutResource = res.resourceId;
        } else {
            layoutResource = R.layout.screen_title_icons;
        }
    }else if ((features & (1 << FEATURE_ACTION_MODE_OVERLAY)) != 0) {
        //...
    } else {
        layoutResource = R.layout.screen_simple;
    }
    //解析实例化系统的布局
    mDecor.onResourcesLoaded(mLayoutInflater, layoutResource);
    //找一个叫android.R.id.content的一个FrameLayout
    ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);
    if (contentParent == null) {
        throw new RuntimeException("Window couldn't find content container view");
    }
    return contentParent;
}

/**
 * The ID that the main layout in the XML layout file should have.
 */
public static final int ID_ANDROID_CONTENT = com.android.internal.R.id.content;
```

前面都是根据窗口的风格修饰类型为该窗口选择不同的窗口根布局文件，后面mDecor调用了onResourcesLoaded()方法将该窗口根布局添加到mDecor这个根视图中去，最后获取一个叫android.R.id.content的一个FrameLayout返回去作为mContentParent

#### 1.4 DecorView.java中的onResourcesLoaded方法——往mDecor中添加根布局

```java
void onResourcesLoaded(LayoutInflater inflater, int layoutResource) {
    mDecorCaptionView = createDecorCaptionView(inflater);
    //实例化layoutResource（被赋予系统布局之后）
    final View root = inflater.inflate(layoutResource, null);
    if (mDecorCaptionView != null) {
        if (mDecorCaptionView.getParent() == null) {
            //将layoutResource实例化的对象添加到DecorView中，去填充DecorView
            addView(mDecorCaptionView,
                    new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));
        }
    } else {
        addView(root, 0, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));
    }
    mContentRoot = (ViewGroup) root;
    initializeElevation();
}
```

所以，setContentView中调用的installDecor()方法就是用来产生mDecor和mContentParent对象。在installDecor方法之后，我们才用上了外面传进来的layoutResID

```java
mLayoutInflater.inflate(layoutResID, mContentParent);
```

#### 补充

在我们平时设置Activity的theme或feature时，如：

```java
//通过java文件设置：
requestWindowFeature(Window.FEATURE_NO_TITLE);
//通过xml文件设置：
android:theme="@android:style/Theme.NoTitleBar"
```

其实我们平时requestWindowFeature()设置的值就是，在创建mContentView的generateLayout方法里面，通过getLocalFeature()获取的，而android:theme属性也是通过该方法里面的getWindowStyle()获取的。所以这下就说清楚了在java文件设置Activity的属性时必须在setContentView方法之前调用requestFeature()方法的原因了。

#### 1.5 PhoneWindow.java的内部接口Callback的onContentChanged方法

分析了PhoneWindow的setContentView方法，我们看他这个方法的后面还会调用一个Callback接口的成员函数onContentChanged来通知对应的Activity组件视图内容发生了变化。

```java
public void setContentView(int layoutResID) {
    //......
    final Callback cb = getCallback();
    if (cb != null && !isDestroyed()) {
        cb.onContentChanged();
    }
}
```

PhoneWindow并没有重写这个方法，在Window这个抽象类中

```java
/**
 * Return the current Callback interface for this window.
 */
public final Callback getCallback() {
    return mCallback;
}
```
mCallback的赋值地方，我们可以找到

```java
public void setCallback(Callback callback) {
    mCallback = callback;
}
```
那么这个方法是在哪里调用的呢？在我们上面Windows知识点的地方，我们知道，Window是Activity的组合成员，那么Activity中对Windows的引用中，肯定调用了这个方法，所以回到Activity中

```java
@UnsupportedAppUsage
final void attach(Context context, ActivityThread aThread,
        Instrumentation instr, IBinder token, int ident,
        Application application, Intent intent, ActivityInfo info,
        CharSequence title, Activity parent, String id,
        NonConfigurationInstances lastNonConfigurationInstances,
        Configuration config, String referrer, IVoiceInteractor voiceInteractor,
        Window window, ActivityConfigCallback activityConfigCallback, IBinder assistToken) {
    //...
    mWindow.setCallback(this);
    //...
}
```

所以Activity也就实现了Callback这个接口，同时也需要实现其内部的onContentChanged()方法

```java
public void onContentChanged() {
}
```

onContentChanged是个空方法。那就说明当Activity的布局改动时，即setContentView()或者addContentView()方法执行完毕时就会调用该方法(因为setContentView和addContentView的最后就调用了`cb.onContentChanged();`，等待接口回调)。

所以当我们写App时，Activity的各种View的findViewById()方法等都可以放到该方法中，系统会帮忙回调。

#### 总结：

可以看出来setContentView整个过程主要是如何把Activity的布局文件或者java的View添加至窗口里，上面的过程可以重点概括为：

1. 创建一个DecorView的对象mDecor，该mDecor对象将作为整个应用窗口的根视图。
2. 依据Feature等style theme创建不同的窗口修饰布局文件，并且通过findViewById获取Activity布局文件该存放的地方（窗口修饰布局文件中id为content的FrameLayout）。
3. 将Activity的布局文件添加至id为content的FrameLayout内。





AppCompatActivity的setContentView()方法首先我们看的是继承自AppCompatActivity的源码

我们从MainActivity点进setContentView()

### 2. 继承自AppCompatActivity

我们还是从setContentView()方法出发

#### 2.1 AppCompatActivity.java的setContentView方法

```java
@Override
public void setContentView(@LayoutRes int layoutResID) {
    getDelegate().setContentView(layoutResID);
}
```

这里再对setContentView追进去，发现只能看到 里面的`public abstract void setContentView(@LayoutRes int resId);`这种抽象方法了

所以我们只能从前面的`getDelegate()`入手

```java
@NonNull
public AppCompatDelegate getDelegate() {
    if (mDelegate == null) {
        mDelegate = AppCompatDelegate.create(this, this);
    }
    return mDelegate;
}
```

这里显示mDelegate是通过AppCompatDelegate中的create()方法创建的，我们进去看一下

```java
@NonNull
public static AppCompatDelegate create(@NonNull Activity activity,
        @Nullable AppCompatCallback callback) {
    return new AppCompatDelegateImpl(activity, callback);
}
```

这里也仅仅是new了一个AppCompatDelegateImpl对象，所以我们的setContentView最终是调用的AppCompatActivity中的setContentView方法，我们进去看

#### 2.2AppCompatDelegateImpl.java中的setContentView方法

```java
@Override
public void setContentView(View v) {
    //创建mDecor
    ensureSubDecor();
    //去拿android.R.id.content的Fragment
    ViewGroup contentParent = mSubDecor.findViewById(android.R.id.content);
    contentParent.removeAllViews();
    contentParent.addView(v);
    mAppCompatWindowCallback.getWrapped().onContentChanged();
}
```


这里其实就没啥好看的了，一个一个点进去，仔细看看就好了。与Activity没啥区别

我们回到AppCompatDelegateImpl上面来，

```java
class AppCompatDelegateImpl extends AppCompatDelegate
        implements MenuBuilder.Callback, LayoutInflater.Factory2 {
}
```

发现他继承了LayoutInflater里面的Factory接口，我们可以查找一下他内部使用LayoutInflater的地方

#### 2.3 AppCompatDelegateImpl.java中的installViewFactory方法

```java
@Override
public void installViewFactory() {
    LayoutInflater layoutInflater = LayoutInflater.from(mContext);
    //如果他的factory为空就给他设置一个factory
    if (layoutInflater.getFactory() == null) {
        //这里的this就是把自己传过去
        LayoutInflaterCompat.setFactory2(layoutInflater, this);
    } else {
        if (!(layoutInflater.getFactory2() instanceof AppCompatDelegateImpl)) {
            Log.i(TAG, "The Activity's LayoutInflater already has a Factory installed"
                    + " so we can not install AppCompat's");
        }
    }
}
```

每次创建View的时候，会调用onCreateView，所以我们过去看看


AppCompatDelegateImpl.java


```java
@Override
public final View onCreateView(View parent, String name, Context context, AttributeSet attrs) {
    return createView(parent, name, context, attrs);
}
```

然后继续跳转到createView()方法中

#### 2.5AppCompatDelegateImpl.java中的createView方法

```java
@Override
public View createView(View parent, final String name, @NonNull Context context,
        @NonNull AttributeSet attrs) {
    //...
    return mAppCompatViewInflater.createView(parent, name, context, attrs, inheritContext,
            IS_PRE_LOLLIPOP, /* Only read android:theme pre-L (L+ handles this anyway) */
            true, /* Read read app:theme as a fallback at all times for legacy reasons */
            VectorEnabledTintResources.shouldBeUsed() /* Only tint wrap the context if enabled */
    );
}
```

然后我们继续进到AppCompatViewInflater中的createView方法：

#### 2.6AppCompatViewInflater.java中的createView方法

```java
final View createView(View parent, final String name, @NonNull Context context,
        @NonNull AttributeSet attrs, boolean inheritContext,
        boolean readAndroidTheme, boolean readAppTheme, boolean wrapContext) {
    final Context originalContext = context;
    //...
    View view = null;

    // We need to 'inject' our tint aware Views in place of the standard framework versions
    switch (name) {
        case "TextView":
            view = createTextView(context, attrs);
            verifyNotNull(view, name);
            break;
        case "ImageView":
            view = createImageView(context, attrs);
            verifyNotNull(view, name);
            break;
        case "Button":
            view = createButton(context, attrs);
            verifyNotNull(view, name);
            break;
        case "EditText":
            view = createEditText(context, attrs);
            verifyNotNull(view, name);
            break;
        case "Spinner":
            view = createSpinner(context, attrs);
            verifyNotNull(view, name);
            break;
        case "ImageButton":
            view = createImageButton(context, attrs);
            verifyNotNull(view, name);
            break;
        case "CheckBox":
            view = createCheckBox(context, attrs);
            verifyNotNull(view, name);
            break;
        case "RadioButton":
            view = createRadioButton(context, attrs);
            verifyNotNull(view, name);
            break;
        case "CheckedTextView":
            view = createCheckedTextView(context, attrs);
            verifyNotNull(view, name);
            break;
        case "AutoCompleteTextView":
            view = createAutoCompleteTextView(context, attrs);
            verifyNotNull(view, name);
            break;
        case "MultiAutoCompleteTextView":
            view = createMultiAutoCompleteTextView(context, attrs);
            verifyNotNull(view, name);
            break;
        case "RatingBar":
            view = createRatingBar(context, attrs);
            verifyNotNull(view, name);
            break;
        case "SeekBar":
            view = createSeekBar(context, attrs);
            verifyNotNull(view, name);
            break;
        case "ToggleButton":
            view = createToggleButton(context, attrs);
            verifyNotNull(view, name);
            break;
        default:
            // The fallback that allows extending class to take over view inflation
            // for other tags. Note that we don't check that the result is not-null.
            // That allows the custom inflater path to fall back on the default one
            // later in this method.
            view = createView(context, name, attrs);
    }
}

@NonNull
protected AppCompatTextView createTextView(Context context, AttributeSet attrs) {
    return new AppCompatTextView(context, attrs);
}

@NonNull
protected AppCompatImageView createImageView(Context context, AttributeSet attrs) {
    return new AppCompatImageView(context, attrs);
}

//....
```

只要我们外部继承了AppCompatActivity，那么我们创建任何的View都会被这里拦截，然后给你返回一个AppCompatXXX

## 四、LayoutInflater的源码

LayoutInflater的使用

```java
View.inflate(this,R.layout.activity_main,null)
LayoutInflater.from(this).inflate(R.layout.activity_main,null)
LayoutInflater.from(this).inflate(R.layout.activity_main,null,false)
```

这里的三种实现方式，其实最终都会调用到第三种上面去，

```java
public static View inflate(Context context, @LayoutRes int resource, ViewGroup root) {
    LayoutInflater factory = LayoutInflater.from(context);
    return factory.inflate(resource, root);
}

public View inflate(@LayoutRes int resource, @Nullable ViewGroup root) {
	return inflate(resource, root, root != null);
}
```

所以我们只用看第三种实现方式

首先我们先看LayoutInflater这个对象是怎么实现的 `LayoutInflater.from(this)`,进入源码

```java
public static LayoutInflater from(Context context) {
    LayoutInflater LayoutInflater =
            (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    return LayoutInflater;
}
```

这里直接就是通过系统的服务拿的，这里进去的时候，getSystemService是一个抽象方法，所以我们只能去Context的实现类`ContextImpl.java`里面查找

```java
//用一个Map对象去保存SystemService对象
private static final Map<String, ServiceFetcher<?>> SYSTEM_SERVICE_FETCHERS =
        new ArrayMap<String, ServiceFetcher<?>>();

//静态代码块去注册一些服务,这里只展示了他注册LAYOUT_INFLATER_SERVICE的代码
static {
    //...
    registerService(Context.LAYOUT_INFLATER_SERVICE, LayoutInflater.class,
                new CachedServiceFetcher<LayoutInflater>() {
            @Override
            public LayoutInflater createService(ContextImpl ctx) {
                return new PhoneLayoutInflater(ctx.getOuterContext());
            }});
    //...
}

public static Object getSystemService(ContextImpl ctx, String name) {
    if (name == null) {
        return null;
    }
    //根据name去获取SystemService
    final ServiceFetcher<?> fetcher = SYSTEM_SERVICE_FETCHERS.get(name);
    //...
    return ret;
}
```

我们通过getSystemService方法获取我们的LayoutInflaterService，而LayoutInflaterService是保存在一个Map集合中的，这个集合并不是外面设置的（因为时机不对，没设置时，我们可能拿到空），而是通过静态代码块设置的，这样的static Map中的对象，系统中只会保存一个实例。

所以，我们通过`LayoutInflater.from(this)`获取到的是一个系统服务，他是由单例模式生成的，内存中只有一个实例

回到我们的inflate源码上来：

```java
public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) {
    final Resources res = getContext().getResources();
	//...
    XmlResourceParser parser = res.getLayout(resource);
    try {
        return inflate(parser, root, attachToRoot);
    } finally {
        parser.close();
    }
}
```

这里通过`res.getLayout(resource);`会获取到一个XmlResourceParser对象（XML解析器），然后我们继续追踪inflate方法

```java
public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) {
    synchronized (mConstructorArgs) {
        //拿到一个Context对象
        final Context inflaterContext = mContext;
        //解析属性
        final AttributeSet attrs = Xml.asAttributeSet(parser);
        //往构造函数添加东西
        Context lastContext = (Context) mConstructorArgs[0];
        mConstructorArgs[0] = inflaterContext;
        View result = root;

        try {
            advanceToRootNode(parser);
            final String name = parser.getName();

            if (DEBUG) {
                System.out.println("**************************");
                System.out.println("Creating root view: "
                        + name);
                System.out.println("**************************");
            }

            if (TAG_MERGE.equals(name)) {
                //如果是merge标签，就不拿
                if (root == null || !attachToRoot) {
                    throw new InflateException("<merge /> can be used only with a valid "
                            + "ViewGroup root and attachToRoot=true");
                }

                rInflate(parser, root, inflaterContext, attrs, false);
            } else {
                // Temp is the root view that was found in the xml
                //从tag里面创建View
                final View temp = createViewFromTag(root, name, inflaterContext, attrs);

                ViewGroup.LayoutParams params = null;

                if (root != null) {
                    if (DEBUG) {
                        System.out.println("Creating params from root: " +
                                root);
                    }
                    // Create layout params that match root, if supplied
                    params = root.generateLayoutParams(attrs);
                    if (!attachToRoot) {
                        // Set the layout params for temp if we are not
                        // attaching. (If we are, we use addView, below)
                        temp.setLayoutParams(params);
                    }
                }

                if (DEBUG) {
                    System.out.println("-----> start inflating children");
                }

                // Inflate all children under temp against its context.
                rInflateChildren(parser, temp, attrs, true);

                if (DEBUG) {
                    System.out.println("-----> done inflating children");
                }

                // We are supposed to attach all the views we found (int temp)
                // to root. Do that now.
                if (root != null && attachToRoot) {
                    root.addView(temp, params);
                }

                // Decide whether to return the root that was passed in or the
                // top view found in xml.
                if (root == null || !attachToRoot) {
                    result = temp;
                }
            }

        } catch (XmlPullParserException e) {
            //...
        } finally {
            // Don't retain static reference on context.
            mConstructorArgs[0] = lastContext;
            mConstructorArgs[1] = null;

            Trace.traceEnd(Trace.TRACE_TAG_VIEW);
        }

        return result;
    }
}
```

我们进到rInflateChildren方法里面，

```java
final void rInflateChildren(XmlPullParser parser, View parent, AttributeSet attrs,
        boolean finishInflate) throws XmlPullParserException, IOException {
    rInflate(parser, parent, parent.getContext(), attrs, finishInflate);
}
```

发现他调用的是rInflate方法，我们再进去

```java
void rInflate(XmlPullParser parser, View parent, Context context,
        AttributeSet attrs, boolean finishInflate) throws XmlPullParserException, IOException {

    while (((type = parser.next()) != XmlPullParser.END_TAG ||
            parser.getDepth() > depth) && type != XmlPullParser.END_DOCUMENT) {
        if (TAG_REQUEST_FOCUS.equals(name)) {
            pendingRequestFocus = true;
            consumeChildElements(parser);
        } else {
            //...
            rInflateChildren(parser, view, attrs, true);
            viewGroup.addView(view, params);
        }
    }
}
```

发现这里又在调用rInflateChildren方法，所以现在的情况是rInflate方法和rInflateChildren在互相的递归调用。

这个源码一直递归调用，我们看另一个方法createViewFromTag

```java
private View createViewFromTag(View parent, String name, Context context, AttributeSet attrs) {
    return createViewFromTag(parent, name, context, attrs, false);
}

View createViewFromTag(View parent, String name, Context context, AttributeSet attrs,
        boolean ignoreThemeAttr) {
    if (name.equals("view")) {
        name = attrs.getAttributeValue(null, "class");
    }
	//...
    try {
        //根据是否设置Factory，来决定onCreateView的方式，如果继承了AppCompatActivity，他就会设置一个Factory，那么
        //这里判断时，就会进入到AppCompatActivity的onCreateView中去，以此来拦截View的原本创建过程
        View view = tryCreateView(parent, name, context, attrs);

        if (view == null) {
            final Object lastContext = mConstructorArgs[0];
            mConstructorArgs[0] = context;
            try {
                //不包含点的，说明是系统的View，这个时候，他就会把他的View名称给拼好
                if (-1 == name.indexOf('.')) {
                    view = onCreateView(context, parent, name, attrs);
                } else {
                    //这个点是为了判别我们自定义View，因为使用自定义View的时候，就需要在布局中提供 包名.类名
                    view = createView(context, name, null, attrs);
                }
            } finally {
                mConstructorArgs[0] = lastContext;
            }
        }

        return view;
    } catch (InflateException e) {
        throw e;
    } 
}

public final View tryCreateView(@Nullable View parent, @NonNull String name,
        @NonNull Context context,
        @NonNull AttributeSet attrs) {
    //...
    View view;
    //根据设置的Factory，来决定onCreateView的方式
    if (mFactory2 != null) {
        view = mFactory2.onCreateView(parent, name, context, attrs);
    } else if (mFactory != null) {
        view = mFactory.onCreateView(name, context, attrs);
    } else {
        view = null;
    }

    if (view == null && mPrivateFactory != null) {
        view = mPrivateFactory.onCreateView(parent, name, context, attrs);
    }
    return view;
}

//如果是系统的View，就到这里来拼接出完整的View名称
protected View onCreateView(String name, AttributeSet attrs)
            throws ClassNotFoundException {
    return createView(name, "android.view.", attrs);
}

public final View createView(@NonNull Context viewContext, @NonNull String name,
            @Nullable String prefix, @Nullable AttributeSet attrs)
            throws ClassNotFoundException, InflateException {
	//做缓存,因为反射比较耗性能
    //从缓存中取出来
    Constructor<? extends View> constructor = sConstructorMap.get(name);
    try {
        Trace.traceBegin(Trace.TRACE_TAG_VIEW, name);
		//如果缓存中没有这个构造器，就去拼接出这个类来
        if (constructor == null) {
            // Class not found in the cache, see if it's real, and try to add it
            //拼接类名
            clazz = Class.forName(prefix != null ? (prefix + name) : name, false,
                                  mContext.getClassLoader()).asSubclass(View.class);
            //构造函数
            constructor = clazz.getConstructor(mConstructorSignature);
            constructor.setAccessible(true);
            sConstructorMap.put(name, constructor);
        } else {
            // If we have a filter, apply it to cached constructor
            if (mFilter != null) {
                // Have we seen this name before?
                Boolean allowedState = mFilterMap.get(name);
                if (allowedState == null) {
                    // New class -- remember whether it is allowed
                    clazz = Class.forName(prefix != null ? (prefix + name) : name, false,
                                          mContext.getClassLoader()).asSubclass(View.class);

                    boolean allowed = clazz != null && mFilter.onLoadClass(clazz);
                    mFilterMap.put(name, allowed);
                    if (!allowed) {
                        failNotAllowed(name, prefix, viewContext, attrs);
                    }
                } else if (allowedState.equals(Boolean.FALSE)) {
                    failNotAllowed(name, prefix, viewContext, attrs);
                }
            }
        }
        //...
        try {
            //通过构造函数去获取实例，这里的构造函数是有两个参数的构造函数，
            //而不是我们Java中调用时的一个参数(Context)的构造函数
            //所以避免布局嵌套，因为嵌套一次，就要来这里反射获取对象一次，导致系统性能降低
            final View view = constructor.newInstance(args);
            if (view instanceof ViewStub) {
                // Use the same context when inflating ViewStub later.
                final ViewStub viewStub = (ViewStub) view;
                viewStub.setLayoutInflater(cloneInContext((Context) args[0]));
            }
            return view;
        } finally {
            mConstructorArgs[0] = lastContext;
        }
    } finally {
        Trace.traceEnd(Trace.TRACE_TAG_VIEW);
    }
}

//这是有两个参数的构造函数，所以可以看出来，我们在布局中(XML文件中)使用的View是调用的2个参数的构造函数生成的
static final Class<?>[] mConstructorSignature = new Class[] {
            Context.class, AttributeSet.class};
```

## 五、换肤使用

因为在Activity的onCreate方法中，super.onCreate(savedInstanceState)就会去设置Factory，所以我们只要在super.onCreate(savedInstanceState)之前设置一个Factory就能拦截到View的创建。所以

```kotlin
override fun onCreate(savedInstanceState: Bundle?) {
    val layoutInflater = LayoutInflater.from(this)
    LayoutInflaterCompat.setFactory2(layoutInflater,object : LayoutInflater.Factory2{
        override fun onCreateView(
            parent: View?,
            name: String,
            context: Context,
            attrs: AttributeSet
        ): View? {
            //拦截到View的创建
            if (name == "Button"){
                val textView = TextView(this@MainActivity)
                textView.text = "被拦截了"
                return textView
            }
            return null
        }

        override fun onCreateView(name: String, context: Context, attrs: AttributeSet): View? {
            //拦截到View的创建
            if (name == "Button"){
                val textView = TextView(this@MainActivity)
                textView.text = "被拦截了"
                return textView
            }
            return null
        }
    })
    super.onCreate(savedInstanceState)
    setContentView(R.layout.activity_main)
}
```

这样，我们activity_main布局中的Button的创建都会被拦截，换成TextView。这样就达到了我们换肤的第三种方案