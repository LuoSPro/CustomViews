自定义View-字体渐变色

## 一、思路：

因为是绘制字体渐变色，而TextView只能显示一种颜色，所以可以考虑一下让我们的View继承自View或TextView，但是如果继承自View的话，光是onMeasure()里面的代码就很多了。所以最后我们考虑继承TextView。

而要实现的功能是：

- 一个文字两种颜色，两个画笔去画
- 能够从左到右渐变，也能从右到左渐变
- 最后将我们自定义实现的View整合到ViewPager中

## 二、实现步骤

### 1、两个画笔

上面分析到，要实现一个View上面两种颜色，就需要用到两个Paint对象，所以我们设置一个originPaint和changePaint对象

```java
//绘制不变字体的画笔
private Paint mOriginPaint;
//绘制变色字体的画笔
private Paint mChangePaint;
```

对其初始化的时候，我们采用常规套路：颜色、防锯齿、防抖动、字体大小等信息

```java
private Paint getPaintByColor(int color) {
    Paint paint = new Paint();
    //设置颜色
    paint.setColor(color);
    //防锯齿
    paint.setAntiAlias(true);
    //防抖动
    paint.setDither(true);
    //设置字体大小
    //这里的getTextSize()是因为继承了TextView，直接从布局那边获取的
    paint.setTextSize(getTextSize());
    return paint;
}
```

那么接下，我们就可以在View的onDraw里面对文字进行绘制

```java
canvas.drawText(text,x,baseLine,paint);//这么画还是只有一种颜色
```

上面是用canvas的drawText()方法对文字进行绘制，但是每次这样只能使一行文字显示一种颜色，所以我们得用到canvas得另一个方法：

```java
canvas.clipRect(rect);
```

这个方法是对我们得canvas上得区域进行裁剪，而传给他的rect对象就是用于规划裁剪区域的，如：

```java
Rect rect = new Rect(start,0,end,getHeight());
```

这样表示的是，将View从start位置到end位置给裁剪出来，只有裁剪出来的这部分才对用户可见，所以我们联想到一行文字显示两种颜色就是将文字裁剪成两个区域，一个从0到middle，另一个颜色从middle到end

```java
Rect origin = new Rect(0,0,middle,getHeight());
Rect origin = new Rect(middle,0,end,getHeight());
```

这样就能将文字分成两个区域，并显示不同的颜色，所以我们封装一下裁剪的这个方法;

```java
private void drawText(Canvas canvas,Paint paint,int start, int end){
    //这个save需要放到裁剪之前，不然后面直接对整个canvas进行裁剪后，后面的changePaint就发挥不了作用了
    canvas.save();
    //绘制不变色的
    Rect rect = new Rect(start,0,end,getHeight());
    //裁剪区域
    canvas.clipRect(rect);
    //如果这里调用了super.onDraw()方法，那么他就会让其父类TextView把文字画出来，就达不到我们渐变文字的效果了
    //super.onDraw(canvas);
    //所以我们自己来画
    String text = getText().toString();
    Rect bounds = new Rect();
    paint.getTextBounds(text,0,text.length(),bounds);
    //获取字体的宽度
    int x = getWidth()/2 - bounds.width()/2;//View的一半 - 文字的一半
    //基线baseLine
    Paint.FontMetricsInt fontMetricsInt = paint.getFontMetricsInt();
    int dy = (fontMetricsInt.bottom - fontMetricsInt.top)/2 - fontMetricsInt.bottom;
    int baseLine = getHeight()/2 + dy;
    canvas.drawText(text,x,baseLine,paint);//这么画还是只有一种颜色
    canvas.restore();
}
```

这上面要注意，canvas,save()方法放置的位置，如果在裁剪之后才调用这个方法，那么第二画笔来绘制的时候，就看不到效果了，因为他此时操作的是已经被裁剪过后的区域。

再说一下这个canvas.save()方法和canvas.restore()方法

- canvas.save()：保存已绘制的图像，使后续操作像在新的图层上操作
- canvas.restore()：把后续的绘图操作和之前保存的图像合并

所以通过两次save和两次restore操作，把两个裁剪区域合并到了一起，这就形成了一行文字出现两种颜色的现象

### 2、不同方向的渐变

从上面的步骤中，我们已经实现了一行文字，两个颜色，但是我们是写死了的，如果middle为一个常量，那么两个颜色的比例不会改变，那么要是这个颜色的比例发生改变，自然我们应该修改middle的值，让他成为一个可变的数，所以在onDraw()中

```java
//根据进度把中间值算出来
int middle = (int) (mCurProgress*getWidth());
if (mDirection == Direction.LEFT_TO_RIGHT){
    drawText(canvas,mOriginPaint,0,getWidth());
    drawText(canvas,mChangePaint,0,middle);
}else{
    drawText(canvas,mOriginPaint,getWidth()-middle,getWidth());
    drawText(canvas,mChangePaint,0,getWidth()-middle);
}
```

所以我们设置一个progress值来改变middle，而这个progress就需要调用者传进来

我们这里通过一个ValueAninator对象来操作

```kotlin
val valueAnimator: ValueAnimator = ObjectAnimator.ofFloat(0f,1f)
valueAnimator.duration = 2000
btn_left_to_right.setOnClickListener {
    color_track_text.setDirection(ColorTrackTextView.Direction.LEFT_TO_RIGHT)
    valueAnimator.addUpdateListener {
        color_track_text.setCurProgress(valueAnimator.animatedValue as Float)
    }
    valueAnimator.start()
}
btn_right_to_left.setOnClickListener {
    color_track_text.setDirection(ColorTrackTextView.Direction.RIGHT_TO_LEFT)
    valueAnimator.addUpdateListener {
        color_track_text.setCurProgress(valueAnimator.animatedValue as Float)
    }
    valueAnimator.start()
}
```

设置其变化范围在(0,1)，这样middle的范围就在(0,getWidth())这个范围，然后通过给ColorTrackTextView设置progress达到一个渐变的效果

